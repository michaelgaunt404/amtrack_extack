---
title: "Amtrak Summary"
output: 
  html_document:
    theme: cerulean
    toc: true
    number_sections: true
    toc_depth: 2
    toc_float: 
      collapsed: true
      smooth_scroll: false
---
***
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, 
                      cache = TRUE, 
                      results = "hide", 
                      warning = FALSE)
```

# Methodology
***
## R Specific Packages Used
***
```{r echo=TRUE, warning = FALSE, message = FALSE}
#package install and load~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
library(data.table)
library(magrittr)
library(dplyr)
library(stringr)
library(lubridate)
library(kableExtra)
library(formattable)
library(knitr)
library(ggplot2)
library(forcats)
library(visdat)
```

## Data Import and Munging
***
```{r}
#package install and load~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#defining asset data columns~~~~~
names_indx = c('assetspecid', 'assetnum', 'assetattrid', 
               'classstructureid', 'displaysequence', 'alnvalue', 
               'changedate', 'changeby',  'Data_Date')

#loading asset data~~~~~
asset = fread("./data/ASSETSPEC 2020-03-16.csv") %>% 
  set_colnames(names_indx) 

#munging asset data~~~~~
index = grepl("SEDTRACKSEGMENT", asset$assetattrid) | 
  grepl("SED_CULVERTSPAN_", asset$assetattrid) |
  grepl("AMTMAX", asset$assetattrid) |
  grepl("JCH", asset$assetattrid) == TRUE

asset_records_removed = asset[index,]  

asset_records_removed %>% 
  fwrite(file = "./output/data/asset_records_removed.csv")

asset = asset[!index,]
```

The data used for this report was `ASSETSPEC 2020-03-16.csv`, it is referred to as ASSETSPEC in this document

The number of records in ASSETSPEC is **`r nrow(asset)`**. 

### Data Filtering
***
The ASSETSPEC data set was filtered to exclude the following items : *SEDTRACKSEGMENT%*, *SED_CULVERTSPAN_%*, *AMTMAX%*, and *%JCH%*.
The first two items were removed because their assetattrids values did not match those in the source files.
In particular, they include the name of the parent source file in each assetattrid making it very difficult to properly join with the source files.     
     
In total, **`r nrow(asset_records_removed)`** were removed from ASSETSPEC from the above filtering.  
A plot of the removed records per filtered item can be seen below.  

```{r results='asis', fig.height=4, fig.width=6, fig.align='left'}
asset_records_removed[str_detect(assetattrid, "SEDTRACKSEGMENT")]$assetattrid = "SEDTRACKSEGMENT" 
asset_records_removed[str_detect(assetattrid, "SED_CULVERTSPAN")]$assetattrid = "SED_CULVERTSPAN" 
asset_records_removed[str_detect(assetattrid, "AMTMAX")]$assetattrid = "AMTMAX" 
asset_records_removed[str_detect(assetattrid, "JCH")]$assetattrid = "JCH" 

asset_records_removed %>%  
  .[,.(.N), by = .(assetattrid)] %>% 
  .[,`:=`(assetattrid = fct_reorder(assetattrid, N, max))] %>% 
  ggplot() + 
  geom_col(aes(assetattrid, N), fill = "light blue") + 
  geom_label(aes(assetattrid, N, label = N)) +
  ylim(c(0,1280000)) +
  coord_flip() +
  labs(x = "", y = "Count", title = "Number of records removed by filtered assetattrid") +
  theme_classic()  
```
   
A small selection of these records can be seen below as an example.    
These items were written out as a csv file titled *asset_records_removed.csv*.    
    
```{r results='asis'}
asset_records_removed %>% 
  sample_n(100) %>%  
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "responsive"), full_width = T, font_size = 11) %>%
  scroll_box(height = "200px")
```

```{r}
#loading source file information data~~~~~
master_id = fread("./data/master_id.csv")
master_id_lookup = fread("./data/master_id_lookup.csv") %>%  
  .[,`:=`(full_src = paste0("./data/", src, ".csv"))]
  

#removing unnneded source file directories
index = grepl("GEO", master_id_lookup$src) | 
  grepl("Speed", master_id_lookup$src) | 
  grepl("Route", master_id_lookup$src) | 
  grepl("Frogs", master_id_lookup$src) | 
  grepl("FROGVERALTVER]", master_id_lookup$src) == TRUE

master_id_lookup = master_id_lookup[!index,]

#merging both files and changing attribute data type
all_source_file_ids = master_id %>%
  merge(master_id_lookup) %>% 
  .[,c(2:3)] %>%  
  unique()

all_source_file_ids$ID = all_source_file_ids$ID %>%  as.integer()
```

```{r}
#ASSETSPEC side EDA and munging~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#assetattrid == SED_ID~~~~~
lookup_asset_num_id = asset[assetattrid == "SED_ID",c(1,2,3,6)] %>% 
  .[order(alnvalue)]
first_num = lookup_asset_num_id %>%  nrow()

lookup_asset_num_id$alnvalue = lookup_asset_num_id$alnvalue %>%  
  as.integer()

#writing out incomplete records
tmp = lookup_asset_num_id[!complete.cases(lookup_asset_num_id)]
bad_num = tmp %>%  nrow()
tmp %>%  
  fwrite(file = "./output/data/assetspec_incomplete_rows.csv")

#complete cases only
lookup_asset_num_id = lookup_asset_num_id[complete.cases(lookup_asset_num_id)]

lookup_asset_num_id %>%  
  fwrite(file = "./output/data/assetspec_complete_rows.csv")
```

### Extracting IDs from ASSETSPEC
***
In total, there were **`r first_num`** ASSETSPEC records where *assetattrid == SED_ID* and with valid *alnvalues*.
Inititally, **`r nrow(lookup_asset_num_id)`** records were returned but **`r bad_num`** records were removed due to missing or poor alnvalue encoding.
These records were exported as a csv titled as **assetspec_incomplete_rows.csv** and then removed from the rest of the analysis.    

### Duplicate ID Check
***
Both the ASSETSPEC and source file data sets were checked for duplicated IDs. This was an important step as the SED_ID values were the primary key between the data sets and duplicated IDs in either data set would confound the mapping process. Speccifically, duplicated IDs present across multiple SED source files would complicate attribute mapping ebtween the datasets as the the source files names were used as foreign keys.       

```{r}
#aggregating duplicated records per field
get_unique = function(list){
  list %>%  
    unique() %>%  
    length()
}

#summary dupe per column
tmp_check = data.table(complete_records = lookup_asset_num_id %>%  nrow(), 
           lookup_asset_num_id %>%  
             purrr::map_df(., get_unique)) %>%  
  melt.data.table(variable.name = "Number of Records per Item", 
                  value.name = "Count") %>%  
  .[,`:=`(non_Distinct_Count = nrow(lookup_asset_num_id)-Count)] %>%  
  .[-4,]
```

The table below reports the number of non-disitnct field vlaues for the filtered ASSETSPEC data. 

* All records were unique
  + This is good, the data transfer to ASSETSPEC only prodcued unique rows
* All assetspecids were unique
  + Each attribute for a specific asset were distinct from other asset attributes of the same type
* There were **`r  print(tmp_check$non_Distinct_Count[3])`** non_distinct assetnums
  + **?????????????**
* There were **`r  print(tmp_check$non_Distinct_Count[4])`** non_distinct alnvalue/SED_IDs\
  + This number can be overlooked
  + Again, duplicated IDs are only a problem if they map to different source files
  + In this case, the duplicated IDs corresponded to "family" of asset nums
    - An example of this can be seen below the table


```{r results='asis'}

tmp_check %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "responsive"), full_width = T, font_size = 11)
```

```{r}
#dupe extract
index_dupe_ids = unique(lookup_asset_num_id[duplicated(alnvalue)]$alnvalue)

#get asset_compelete dupe ids
lookup_asset_num_id_duplicated = lookup_asset_num_id[which(alnvalue %in% index_dupe_ids),]

lookup_asset_num_id_duplicated[, c(2,4)] %>% 
  unique() %>%
  head(6) %>% 
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "responsive"), full_width = T, font_size = 11)
  
lookup_asset_num_id_duplicated %>% 
  fwrite(file = "./output/data/assetspec_duplicated_ids.csv")
```

```{r}
#gets source ID dupes 
sfiles_duplicated_ids = all_source_file_ids[which(ID %in% unique(all_source_file_ids[duplicated(ID)]$ID)),] %>%  
  .[order(ID)]

sfiles_duplicated_ids %>% 
  fwrite(file = "./output/data/sfiles_duplicated_ids.csv")
```

```{r results='asis'}
#sorts all source files by dupe ids
different_source_duplicates = all_source_file_ids[which(ID %in% index_dupe_ids)] %>% 
  .[order(ID)]
```

The source files were also checked for duplicate IDs, in total there were **`r nrow(sfiles_duplicated_ids)`** duplicate IDs. All duplicate IDs occured betwen **`r length(unique(sfiles_duplicated_ids$src))`** source files - **`r  unique(sfiles_duplicated_ids$src)`**. This would only be problematic if the ASSTESPEC data contained one of these IDs. As it turned out there were no such conflict, all of the duplicated IDs in the ASSETSPEC data mapped to distinct source files. The **`r nrow(lookup_asset_num_id_duplicated)`** IDs present in the duplicated IDs ASSETSPEC records mapped to **`r nrow(different_source_duplicates)`** unique IDs from the source files. Non of these IDs mapped to mulitiple source files confiming there was no potential for incorrect attribute mapping due to issues with the foreign or primary keys between the data sets. 

```{r}
#checks to see if there dupes from different source files
different_source_duplicates = setDT(different_source_duplicates)[, if(.N > 1) .SD, by = ID]
```


### Data Set Merging
***
As implied above, the ASSETSPEC records with positive SED_ID *assetattrids* with valid *alnvalues* were mapped to a lookup table containing all source file IDs and their respective source file names. This set which produced a table containneing the filtered ASSETSPEC sed_ids and their corresponding source file names.    

```{r}
#section~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#merges all relevant source SED extract IDs with nonempty asset IDS
raw_merge = all_source_file_ids %>% 
  merge(., 
        lookup_asset_num_id, 
        by.x = "ID", 
        by.y = "alnvalue", 
        all = TRUE) %>% 
  data.table() %>% 
  unique()

duplicate_id_check = raw_merge %>%  
  semi_join(different_source_duplicates[,1], by = 'ID') %>%  
  data.table() %>% 
  .[order(ID, assetnum)]
```

The ASSETSPEC data was filtered again for all records with matching *assetnum* values as the SED_ID reocrds. This produced a table with all records related to the psotively matched sed_id values. After checkinig for duplicate IDs, the ASSETSPEC were merged with above table. All ASSETSPEC records now included an ID and source file mapping, enabling each ASSETSPEC record attribute to be linked to a corrseponding sed_file attibute for a given a distinct ID. 

```{r}
#full merge check and identification of NA records
merge_check_NA = raw_merge[!complete.cases(raw_merge)] #all rows w/ NA
merge_check_NA_num_total = merge_check_NA %>%  nrow()

# merge_check_NA %>%  
  # visdat::vis_dat(sort_type =  FALSE)

merge_check_NA_src = merge_check_NA[is.na(src)] #records w/ asset data but no s.file date
merge_check_NA_src_num = merge_check_NA_src %>%  nrow()

merge_check_NA_assetnum = merge_check_NA[is.na(assetnum)] #records w/ s.file date but no asset data
merge_check_NA_assetnum_num = merge_check_NA_assetnum %>%  nrow()

```

```{r}
#matched IDs b/w SEDEXTARCT and ASSETSPEC 
#complete cases
master_matched_ids = raw_merge %>%  
  na.omit() %>%  
  unique()

duplicated_id_list = master_matched_ids[duplicated(ID),1] %>%  
  unique()

duplicated_record_list = master_matched_ids[duplicated(master_matched_ids),]

master_matched_ids_duplicate_rm = anti_join(master_matched_ids,
                                            duplicated_id_list,
                                            by = "ID") %>%
  data.table() %>%
  .[order(ID), c(1:4)]

#THIS IS IMPORTANT SHOULD THEY BE REMOVED??? THEY ARE CURRENTLY NOT
master_matched_ids_duplicate_only = semi_join(master_matched_ids,
                                              duplicated_id_list,
                                              by = "ID") %>%
  data.table() %>%
  .[order(ID),] 


```

   
This was done to match each unique *SED_ID* in ASSETSPEC to it's respective source file.     
In total, there were **`r nrow(master_matched_ids)`** matches.    

```{r}
#section~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#DT below has all records ASSETNUMS where their SED_ID values were found
asset_merged = lookup_asset_num_id %>%  
  semi_join(asset[,c(1,2,3,6)], ., by = c("assetnum")) %>% 
  merge(., master_matched_ids[,c(-3,-5)], by = c("assetnum")) %>% 
  data.table() %>% 
  unique()

asset_merged$ID = as.integer(asset_merged$ID)

#full merge check and identification of NA records
merge_check_NA = asset_merged[!complete.cases(asset_merged)] #all rows w/ NA
merge_check_NA_num_total = merge_check_NA %>%  nrow()

asset_merged %>% 
  .[,c('src', 'ID')] %>%  
  unique() %>% 
  .[order(src)]

asset_merged$ID %>%  
  unique() %>% 
  length()

```


```{r}
# COMMENT OUT WHEN DONE 
# PERFORMS CHECK ON DUPLICATED COLNAMES IN ASSETSPEC 
tmp = asset_merged %>%  
 .[str_detect(assetattrid, "2")] %>%  
  .[,.(assetattrid, src)] %>% 
  unique() 

tmp$assetattrid = str_remove_all(tmp$assetattrid, pattern = "2") %>% 
    gsub('^\\.|\\_$', '', .) %>%  
    gsub('^\\.|\\-$', '', .)

yolo = asset_merged[grepl(paste0(tmp$assetattrid, collapse = "|"), assetattrid)] %>%  
  .[,.(src, assetattrid)] %>% 
  unique()

duplicated_colname_extract_side = yolo[which(src %in% tmp$src)] %>%  
  .[order(src, assetattrid)] 
duplicated_colname_extract_side %>%  
  fwrite(file = "./output/data/potential_duplicated_colname_extract_side.csv")
```

The result of this was a filtered ASSETSPEC data set only contianed *asstenum* records whose SED_IDs had been extracted and properly mapped to the source files.  
Each record of this new table detailed a specific assetasttrid, the corresponding value for that attribute, and a foreign and primary, an SED_ID and source file.


All records with matching assetnum values corresponding to the *SED_ID* records were extracted from ASSETSPEC. In total, there were **`r nrow(asset_merged)`** records extracted from ASSETSPEC. These records would be then matched against the corresponding source files attribute values.

```{r}
#removing SED_TUNNEL, has bad headers
# index = grepl("Tunnel", asset_merged$src)
# asset_merged = asset_merged[!index,]

index = grepl("ALTVER", asset_merged$src)
asset_merged = asset_merged[!index,]

#Extracting all matched ASSETxSEDEXTRACT records' columns and values
suppressMessages({ 
  suppressWarnings({
    
    retreived_source_id_info = data.table()
    
    print("Extracting data from the following source files:")
    for (i in unique(asset_merged$src)){
      
      print(i)

      tmp = asset_merged %>% 
        .[src == i,ID] %>%  
        unique()

      retreived_source_id_info = master_id_lookup[src == i,full_src] %>%
        fread(., colClasses = 'character') %>% 
        .[ID %in% tmp,] %>% 
        .[,`:=`(id = ID)] %>%  
        purrr::map_df(as.character) %>% 
        reshape2::melt(id.vars = c("ID"), 
                       variable.factor = FALSE, 
                       warning = FALSE) %>% 
        data.table() %>% 
        .[,`:=`(assetattrid = paste0("SED_", str_to_upper(variable)))] %>%  
        bind_rows(retreived_source_id_info, .)
    }
    print("Done")
  })
})

retreived_source_id_info$ID = retreived_source_id_info$ID %>%  
  as.integer()

```

```{r}
# index = grepl("Tunnel", asset_merged$src)
# asset_merged = asset_merged[!index,]
# 
# index = grepl("ALTVER", asset_merged$src)
# asset_merged = asset_merged[!index,]
# 
# #Extracting all matched ASSETxSEDEXTRACT records' columns and values
# suppressMessages({ 
#   suppressWarnings({
#     
#     tmp_data = data.table()
#     
#     print("Extracting data from the following source files:")
#     for (i in unique(asset_merged$src)){
#       
#       print(i)
# 
#       tmp = asset_merged %>% 
#         .[src == i,ID] %>%  
#         unique()
# 
#       tmp_data = master_id_lookup[src == i,full_src] %>%
#         fread(., colClasses = 'character', nrows = 1) %>% 
#         colnames() %>%  
#         data.table(src = i, 
#                    attribute = .) %>% 
#         bind_rows(tmp_data, .)
#     }
#     print("Done")
#   })
# })
# 
# tmp_data$ID = retreived_source_id_info$ID %>%  
#   as.integer()
# 
# duplicated_attributes = tmp_data %>%  
#   semi_join(tmp_data[duplicated(tmp_data)], by =c("src", 'attribute')) %>%  
#   data.table() %>% 
#   .[order(src, attribute)] %>%  
#   .[,`:=`(attribute = paste0("SED_",str_to_upper(attribute)))] 
# 
# merge(duplicated_attributes, 
#           asset_merged[, .(src, assetattrid)], 
#           by = c("src"),
#           suffix = c('.extract', '.assetspec'))
# 
# duplicated_attributes %>%  
#   fwrite(file = "./output/data/duplicated_attributes_extract_side.csv")
# ?semi_join
# asset_merged[, .(src, assetattrid)]
# 
# duplicated_attributes %>%  
#   unique() %>% 
#   merge(asset_merged[,c("src", "assetattrid")] %>%  
#           unique() %>%  
#           .[str_detect(assetattrid, "2")], 
#         by = c("src"), 
#         suffixes = c('.extract', '.assetspec'), 
#         allow.cartesian=TRUE)
# 
# asset_merged[str_detect("2")]
# asset_merged$assetattrid %>%  unique() %>% str_detect("2") 
```


```{r results='asis', fig.height=4, fig.width=6, fig.align='left'}
#full merge check and identification of NA records
merge_check_NA = retreived_source_id_info[!complete.cases(retreived_source_id_info)] #all rows w/ NA
merge_check_NA_num_total = merge_check_NA %>%  nrow()

# merge_check_NA %>%  
  # visdat::vis_dat(sort_type =  FALSE)

```

```{r}
# retreived_source_id_info[value == ""]$value = "NULL"
```

## Source File Attributes
***
All matched SED_IDs' attribute data were then extracted from the source files.   
In total, this extraction resulted in **`r nrow(retreived_source_id_info)`** records.   
Each record in this table represents an attribute for a particular matched *SED_ID* value.   
This table was then joined with all the extracted records from ASSETSPEC on the record's *SED_ID* and *assetattrid*. 

# Initial ASSETSEPC & Extract Merge
***
```{r}
#section~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#investigating mismatched occurance
colum_order_index = c("src", "assetnum", "ID", "assetspecid", 
                      "assetattrid", "variable", "alnvalue", "value")

attribute_value_master = merge(asset_merged, 
                               retreived_source_id_info, 
                               by.x = c("ID", "assetattrid"), 
                               by.y = c("ID", "assetattrid"), all = TRUE) %>%  
  unique() %>% 
  .[,..colum_order_index] %>%
  .[order(src, ID, assetnum, assetattrid,)] %>% 
  .[,-1] %>%  
  merge(., all_source_file_ids, by = "ID" ) %>% 
  .[,..colum_order_index] %>%  
  .[order(src, ID, assetnum, assetattrid,)]

index = grepl("JCH", attribute_value_master$assetattrid) 
attribute_value_master = attribute_value_master[!index]

attribute_value_master_rows = attribute_value_master %>%  nrow()

attribute_value_master %>% 
  .[duplicated(variable)]
```

## Summary
***
The raw merge of these two tables resulted in **`r nrow(attribute_value_master)`** records. 
The table's columns are:   

* src -> the source file associated with the SED_ID
* assetnum -> the assetnum associated with 
* ID -> the SED_ID for that record
* assetattrid -> the attribute name from the ASSETSPEC table
* variable -> the attribute name from the source files
* alnvalue -> the value associated with the attribute from the ASSETSPEC table
* value -> the value associated with the attribute from the source files

## Incomplete Records
***
```{r}
merge_check_NA = attribute_value_master[!complete.cases(attribute_value_master)] #all rows w/ NA
merge_check_NA_num_total = merge_check_NA %>%  nrow()

na_count = is.na(merge_check_NA) %>%  
  data.table() %>% 
  .[,.(.N), by = .(src, ID, assetnum, assetspecid, assetattrid, alnvalue, variable, value)] %>% 
  .[,-c('src', 'ID', 'assetattrid')] 

```

A large number of incomplete records (containing missing values) resulted from the data merge. In total, there were **`r  merge_check_NA_num_total`** incomplete records which was roughly **`r  100*round(merge_check_NA_num_total/nrow(attribute_value_master), 3)`** percent of the resulting data merger. This number of incomplete records and the distinct pattern they appeared in indicate specific poibnts where either source could not map to the other. As an aside, NAs are different than *NULL* character values and as they are input values implying no data.   
      
There were two potential causes for this:
     
* Missing Data - eg. source 1 contains data source 2 does not, or visa versa
* Incorrect data repersentation - eg. attributes present in both datasets but attribute neames vary for some reaosn

The plot below depicts the total number of incomplete/NA records and the prevailing patterns in which the NAs occured. The  

```{r results='asis', fig.height=4, fig.width=6, fig.align='left'}
#full merge check and identification of NA record
missing_data_viz = merge_check_NA %>%  
  .[,.(src, ID, assetnum, assetspecid, assetattrid, alnvalue, variable, value)] %>%  
  .[order(assetnum)] %>% 
  vis_dat(warn_large_data = FALSE, 
          sort_type = FALSE)

missing_data_viz
```

The table below details the NA type pattern, the number of occurances, and an emblematic example of record with said NA type (record examples start at column **assetnum** to **value**.    
       
* **Row 1**:    
  + Instances where ASSETSPEC data were missing while source file data were present. 
  + This could have arisen two ways
  + Potential Cause: 
    - Data in source files simply absent in ASSETSPEC
    - Not all data was tranferred to ASSETSPEC
  + It is difficult to determine the root cause of this incomplete record type
* **Row 2**:
  + Instances where ASSETSPEC data were present while source file data were missing 
  + Potential Cause: assetattrids don' map between data sets 
    - ASSETSPEC assetattrid changed in transfer 
    - Source file attribute names were doubled up
  + It is easy to determine the root cause of this incomplete record type
    - Emphasis on fixing this type of incomplete record first
* **Row 3**:
  + Data set attributes map between data sets, both values don't exist 
  + Both should be turned to "NULL" stings
    - Could be considered a positive match between values
* **Row 4**:
  + Source file value is missing while corresponding value is present 
  + Very strange but very low count

```{r results='asis'}

ffmerge_na_no_asset_data =  merge_check_NA[is.na(assetnum) &
                 is.na(assetspecid) &
                 is.na(alnvalue) &
                 !is.na(variable) &
                 !is.na(value),]
ffmerge_na_no_asset_data %>% 
  fwrite(file = "./output/data/ffmerge_na_no_asset_data.csv")

ffmerge_na_no_extract_data = merge_check_NA[!is.na(assetnum) &
                 !is.na(assetspecid) &
                 !is.na(alnvalue) &
                 is.na(variable) &
                 is.na(value),]
ffmerge_na_no_extract_data %>% 
  fwrite(file = "./output/data/ffmerge_na_no_extract_data.csv")
                 
ffmerge_na_no_alnvalue_value = merge_check_NA[!is.na(assetnum) &
                 !is.na(assetspecid) &
                 is.na(alnvalue) &
                 !is.na(variable) &
                 is.na(value),]
ffmerge_na_no_alnvalue_value %>% 
  fwrite(file = "./output/data/ffmerge_na_no_alnvalue_value.csv")

ffmerge_na_no_value = merge_check_NA[!is.na(assetnum) &
                 !is.na(assetspecid) &
                 !is.na(alnvalue) &
                 !is.na(variable) &
                 is.na(value),]
ffmerge_na_no_value %>% 
  fwrite(file = "./output/data/ffmerge_na_no_value.csv")

ffmerge_summary_table = bind_cols(data.table(na_type = c('no_asset_data', 
                                 'no_extract_data', 
                                 'no_alnvalue_value',
                                 'no_value'), 
                     na_count = na_count$N),
          bind_rows(ffmerge_na_no_asset_data[1,], 
                    ffmerge_na_no_extract_data[1,],
                    ffmerge_na_no_alnvalue_value[1,],
                    ffmerge_na_no_value[1,]) %>%  
            .[,.(src, ID, assetnum, assetspecid, assetattrid, alnvalue, variable, value)]) 

ffmerge_summary_table %>% 
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "responsive"), full_width = T, font_size = 11) %>%
  scroll_box(height = "200px", width = "100%") 
```

```{r}
attribute_value_master = attribute_value_master %>%  
  na.omit()

attribute_value_master_good_row = attribute_value_master %>%  nrow()
```

All incompelete records were exported and saved as csv files titled:

* ffmerge_na_no_asset_data
* ffmerge_na_no_alnvalue_value
* ffmerge_na_no_extract_data
* ffmerge_na_no_value

```{r}
#matching columns but 
attribute_value_notmatching =  attribute_value_master %>% 
  .[alnvalue != value,] %>% 
  .[,..colum_order_index] %>%  
  .[order(src, ID, assetnum, assetattrid,)]

attribute_value_matching = attribute_value_master %>% 
  .[alnvalue == value,] %>% 
  .[,..colum_order_index] %>%  
  .[order(src, ID, assetnum, assetattrid,)]
```

These incomplete records were removed from the rest of the analysis resulting in **`r nrow(attribute_value_notmatching) + nrow(attribute_value_matching)`** complete records - **`r nrow(attribute_value_notmatching)`** failed matches and **`r nrow(attribute_value_matching)`** positive matches. 

### Missing Source File Data
Special attention should be applied to this incomplete record type. After additional analysis, it appears that this record type is the result a special type of **assetattrid** mappring error. It turns out that some sed souce files contained duplicate attribute column names which caused confusiton for the data transfer process. To deal with the duplicated column names, the transfer process appended a **2** to the second instance of a duplicated sed file column name. As it currently stands, neither value for a given altered/unaltered assteattrid pair can properly map back to it's corresponding source file value. 

This issue can be simply fixed by manually changing the source file column names to the mirror the ASSETSPEC data.

The table below detials the number of occurances per souce file and assetattrid. 
```{r results='asis'}
ffmerge_na_no_extract_data[,.(count = .N), by = .(src, assetattrid)] %>%  
  .[order(assetattrid, -count)] %>%  
  semi_join(duplicated_colname_extract_side, on = c("src", "assetattrid")) %>%
    kable(escape = F, caption = "405LB") %>%
    kable_styling(bootstrap_options = c("striped", "hover", "responsive"), full_width = F, font_size = 11) %>%
    scroll_box(height = "200px")
```


## Type 1 Value Mismatches
***
Spot checks were perfromed on the records which returned megative matches. The intial merge produced a number of Type 1 errors regarding falsely identified *alnvalue/value* mismatches. There were a variety of reasons why this occured ranging from the mundane - CASE errors between the two data source - to more substantial issues - R encoding errors of special characters or space charatcer padding. The former is an example of an easy fix that ccould easily be deployed on the ASSETSPE data. The latter is more complicated to deal with, from the *R/match analysis* point of view it is difficult to determine where the error orginated. In either instance, many mismatches were deemed to be falsely attributed to the record transfer process. A manual check process was carried out on cannonical error types and flagged as a simple difference in format or something requiring more much work to ensure proper match identification.     
       
Some examples of this will be listed below:   

### Case and Whitespace
***
```{r results='asis'}
#removes all mismatch cases caused by CASE or whitespace issues
index_character_mismatch = str_trim(str_to_lower(attribute_value_notmatching$alnvalue), side = "both") == str_trim(str_to_lower(attribute_value_notmatching$value),side = "both")
tmp = attribute_value_notmatching[!index_character_mismatch]
```

```{r results='asis'}
total_matched_example_case_whitespace_sensitive = attribute_value_notmatching[index_character_mismatch]
total_matched_example_case_whitespace_sensitive %>% 
  fwrite(file = "./output/data/total_matched_example_case_whitespace_sensitive.csv")
```
This match error resulted in **`r nrow(total_matched_example_case_whitespace_sensitive)`** records. This error was caused by the data transfer process but can be dismissed as the values practitically match.

An sample of this type of matched error can be seen below:
```{r results='asis'}
total_matched_example_case_whitespace_sensitive %>% 
  sample_n(5) %>% 
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "responsive"), full_width = T, font_size = 11) #%>%
  # scroll_box(height = "200px")
```


### Numeric Padding
***
```{r}
#removes all records where mismatch was caused by false padding encoding
index_alnvalue = as.numeric(tmp$alnvalue)
index_alnvalue[is.na(index_alnvalue)] = 0

index_value = as.numeric(tmp$value)
index_value[is.na(index_value)] = -29348576.127

index_PADDING_mismatch = index_alnvalue == index_value

total_matched_example_padding = tmp[index_PADDING_mismatch]
tmp = tmp[!index_PADDING_mismatch]
```

```{r results='asis'}
vairable_type = total_matched_example_padding %>% 
  .[,.(count = .N), by = .(variable)] %>%
  .[order(-count)]
  
total_matched_example_padding %>% 
  fwrite(file = "./output/data/total_matched_example_padding.csv")
```

```{r}
total_matched_example_padding[as.integer(value) == as.integer(alnvalue)]
```

This match error resulted in **`r nrow(total_matched_example_padding)`** records. The entireity of these msimatches stemmed from R, this was confirmed in two ways - via manual spot chekcs of the source files as well as by converting both ASSETSPEC and source file values to integers which stripped away the padded zeros yeilding a positve match. This paddimg was either an encoding error commited by R or a result of frequent data type conversion nessissitated by the ASSETSPEC data format where both numeric and string values were stored in the same column. In either case, these records were deemed incorrect mismatchs and were removed.  

The table below displays cannonical versions of these error types along with the impacted assetattrid and error occurance number:
```{r results='asis'}
total_matched_example_padding[!duplicated(variable)] %>%  
  .[match(vairable_type$variable, variable),] %>%  
  merge.data.table(vairable_type, ., by = c("variable")) %>%
  .[order(-count)] %>% 
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "responsive"), full_width = T, font_size = 11) %>% 
  add_header_above(c("Summary" = 2, "Example Record" = 7)) %>%
  scroll_box(height = "200px") 

```

### Rounding
***
```{r results='asis'}
#removes long/lat columns as proven to be just a rounding error
index = grepl("LONG", tmp$assetattrid) | grepl("LATITUDE", tmp$assetattrid)
rounding = tmp[index]
rounding %>% 
  fwrite(file = "./output/data/total_matched_example_rounding.csv")
```

This match error resulted in **`r nrow(rounding)`** records. Again, this type of inproperly identified mismatch error type seemed to soley be produced by R and only impact latitude and longitude related *assetattrids*. R encoded more digits than what the default excel display default was and what the data transfer produced. 

An sample of this type of matched error can be seen below:
```{r results='asis'}
tmp[index] %>% 
  sample_n(5) %>% 
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "responsive"), full_width = T, font_size = 11)

tmp = tmp[!index]
```

### Special Characters
***
```{r results='asis'}
#removes all records where mismatch was caused by false encoding
index_DIMENSIONS = tmp$assetattrid == "SED_DIMENSIONS"

total_matched_bad = tmp[!index_DIMENSIONS] 

tmp[index_DIMENSIONS]  %>% 
  fwrite(file = "./output/data/total_matched_example_seddimensions.csv")

bad_special = nrow(tmp[index_DIMENSIONS])
```

This match error resulted in **`r bad_special`** records. Again, this type of inproperly identified mismatch error type seemed to soley be produced by R. R was not able to properly encode the large number of special characters used to describe different types of dimensional data.  

An sample of this type of matched error can be seen below:
```{r results='asis'}
tmp[index_DIMENSIONS] %>% 
  sample_n(5) %>% 
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "responsive"), full_width = T, font_size = 11) #%>%
  # scroll_box(height = "200px") 
``` 

### Date Format Mismatch 
***
```{r}
#identify date records 
tmp_time_dt = total_matched_bad[str_detect(total_matched_bad$assetattrid, "DATE") ,] 

date_pos_match_excel = tmp_time_dt[value %>%  
               ymd_hms() %>%  
               date() == alnvalue %>% 
               as.numeric() %>% 
               as.Date(origin = "1899-12-30"),]

date_pos_match_format = tmp_time_dt[str_detect(alnvalue, "/")] %>% 
  .[value %>%  
            ymd_hms() %>%  
            date() == alnvalue %>%  
            mdy_hm(format = "%Y-%m-%d") %>%  
            as_date() %>% 
            na.omit(),]

tmp_time_dt_remaining = tmp_time_dt %>%  
  anti_join(date_pos_match_excel, by = c("ID", "assetspecid")) %>%  
  anti_join(date_pos_match_format, by = c("ID", "assetspecid")) %>%  
  data.table()

# tmp_time_dt_remaining %>%
#   .[,.(.N), by = .(alnvalue, value)]
# 
# 
# date_pos_match_excel %>% 
#   glimpse() 
# 
# "1900-01-01"
# "1899-12-30"
# tmp =  tmp_time_dt %>%   
#   .[,`:=`(alnvalue_nu = alnvalue %>% 
#             as.numeric() %>%
#             round(0) %>% 
#             as.Date(origin = "1900-01-01", format = "%Y-%m-%d"), 
#           value_nu = value %>%  
#             ymd_hms() %>%  
#             as_date())] %>% 
#   # .[,`:=`(diff = alnvalue_nu - value_nu)] %>%  
#   # .[diff != as.difftime(2, units = "days")]
#   # .[(alnvalue_nu - value_nu) == as.difftime(2.53385, units = "days"),]
#   .[,.(count = .N), by = .(alnvalue_nu - value_nu)] %>%  
#   .[order(-count)]
#   .[,.(alnvalue_nu - value_nu)] %>%
#   .[,.]
#   .[alnvalue_nu - value_nu == "2.53385",]
# 
# tmp1 = tmp_time_dt[str_length(alnvalue) >7]  %>%
#   .[,`:=`(alnvalue_nu = alnvalue %>% 
#             as.numeric() %>%
#             round(0) %>% 
#             as.Date (origin = "1900-01-01", format = "%Y-%m-%d %H:%M:%S") %>% 
#             as_datetime(), 
#           value_nu = value %>%  
#             ymd_hms() %>%  
#             as_datetime())]
#  as.Date(40842.63026, origin = "1900-01-01")


```

Out of the initial **`r nrow(attribute_value_notmatching)`** mismatch records, **`r nrow(tmp_time_dt)`** of those records had dates/time related attirbutes and values. The ASSETSPEC data recorded dates in a number of ways, this made it difficult to apply a ringle robust value mathing comparision with the source file date values, the latter of which followed a single conventional format: *%Y/%m/%d %H:%M:%S*. 

Some of the common ASSETSPEC date formats are listed below:   
   
* Excel numeric format - days since 1900-01-01
* Excel numeric format with decimals - days since 1900-01-01 with decimal days
* Excel date format - *%d-%m-%Y*
* Errors - eg. 0 dates or NULL character strings

A single technique was applied to the "Excel numeric" date values to determine if the true match occurances, this resulted in **`r nrow(date_pos_match_excel)`** psotive match records. The correction of the "Excel date" formatting returned **`r nrow(date_pos_match_format)`** records which matched the source files vlaues. In total, **`r nrow(date_pos_match_excel) + nrow(date_pos_match_format)`** date records failed to properly match due to differences in format despite repersenting the correct date in their own right. **`r nrow(tmp_time_dt_remaining)`** of the original date records still produced these neagtive matches. 

An example of these records can be seen below:

```{r results='asis'}
total_matched_bad = total_matched_bad %>%  
  anti_join(date_pos_match_excel, by = c("ID", "assetspecid")) %>%  
  anti_join(date_pos_match_format, by = c("ID", "assetspecid")) %>%  
  data.table()

tmp_good_date = date_pos_match_excel %>%  
  bind_rows(date_pos_match_format) %>%  
  data.table()

tmp_good_date %>%
  fwrite(file = "./output/data/total_matched_example_gooddates.csv")

tmp_time_dt_remaining %>%
  fwrite(file = "./output/data/total_matched_example_baddates.csv")

tmp_good_date %>% 
  sample_n(5) %>% 
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "responsive"), full_width = T, font_size = 11) %>%
  scroll_box(height = "200px") 
```

```{r}

total_matched_good = attribute_value_master %>%  
  anti_join(total_matched_bad, by = c('assetnum', 'assetspecid', "assetattrid")) %>%  
  data.table()

total_matched_bad %>%  
  fwrite(file = "./output/data/total_matched_bad.csv")

total_matched_good %>%  
  fwrite(file = "./output/data/total_matched_good.csv")
```

# Final ASSETSEPC & Extract Merge 
***
## Summary
***
**`r nrow(total_matched_good)`** records were properly matched on the *alnvalue* and *value* coulmns.        
Examples of these records can are below:   
    
```{r results="asis"}
total_matched_good %>% 
  sample_n(200) %>% 
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "responsive"), full_width = T, font_size = 11) %>%
  scroll_box( height = "200px")
```
   
*CAUTION: Some values may appear to be non-matching, this is likely due to an encoding error produced by R. Most of these types of mismatches are accounted for and are addressed below.  

The number of false matched records is **`r nrow(total_matched_bad)`**. Examples of these records can are below:   
```{r results="asis"}
total_matched_bad %>%
  sample_n(200) %>% 
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "responsive"), full_width = T, font_size = 11) %>%
  scroll_box(height = "200px") 

fail_percent = 100*nrow(total_matched_bad)/(nrow(total_matched_bad)+ nrow(total_matched_good))
```

The match failure rate is roughly **`r fail_percent`** percent.

## Failed Match Diagnostics
***

### Total Records   
The table below details:    
      
* The source file where the matched ID record came from
* Total matches - where IDs and *assetattrids* metched between the source files and ASSETSPEC 
* Number of postive matches - where the alnvalue and value matched or were deemed a 'match' by manual inspection
* Failed matches
* Failure rate in percent

The table indicates where most of the failures originated from and where effort should be placed to buy down match errors.

```{r results="asis"}
summary_diagnostic = total_matched_bad %>%  
  .[,.(fail = .N), by = .(src)] %>%  
  merge(total_matched_good %>%  
          .[,.(pass = .N), by = .(src)], on = "src") %>%  
  .[,`:=`(total = fail + pass)] %>% 
  .[,`:=`(fail_per = 100*round(fail/total,3))] %>%  
  .[order(-fail)] 

summary_diagnostic %>% 
  .[order(-fail)] %>% 
  mutate(
    fail_per = ifelse(fail_per < fail_percent,
                              cell_spec(fail_per),
                              cell_spec(fail_per, 
                                        background = "red", 
                                        color = "white", 
                                        align = "center"))
  ) %>% 
  kable(escape = F) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "responsive"), full_width = T, font_size = 11) %>%
  scroll_box( height = "200px") 


```


### Null values kept   
***
The two tree plots below give an indication to the scope and scale of mismatched values.       
The top plot indicates mismatched records by source file and the bottom plot by *assetattid*.  
They report all mismatches between *alnvalue* and *value* regadless if **NULL** isa present in either.  

```{r results='asis', fig.height=4, fig.width=8, fig.align='left'}

summary_diagnostic %>%  
  .[,`:=`(src = str_remove(src, "SED_"))] %>%
  treemap::treemap(., 
                 index = "src", 
                 vSize = "fail", 
                 vColor = "fail_per",
                 type = "value", 
                 title = "Failed matches per originating source file")
```

```{r}
summary_diagnostic = total_matched_bad %>%  
  .[,.(fail = .N), by = .(assetattrid)] %>%  
  merge(total_matched_good %>%  
          .[,.(pass = .N), by = .(assetattrid)], on = "assetattrid") %>%  
  .[,`:=`(total = fail + pass)] %>% 
  .[,`:=`(fail_per = 100*round(fail/total,3))] %>%  
  .[order(-fail)] %>%  
  .[,`:=`(assetattrid = str_remove(assetattrid, "SED_"))]

```

```{r results='asis', fig.height=4, fig.width=8, fig.align='left'}
treemap::treemap(summary_diagnostic, 
                 index = "assetattrid", 
                 vSize = "fail", 
                 vColor = "fail_per",
                 type = "value", 
                 title = "Failed matches per assetattributeid")
```

### Null Values Removed 
***
The plots below display the same data as above but with all records containing **NULL** in either *alnvalue* or *value* removed.   
These should be used in direct comparison with the plots above
These are TRUE mismatch cases where there were reported values for each matched ID attribute in both datasets but were wrond for some reason.  
      
```{r results="asis"}
#poor match metrics~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
total_matched_bad_non_null = total_matched_bad[alnvalue != "NULL" &  value != "NULL"]
total_matched_bad_non_null %>%  
  fwrite(file = "./output/data/total_matched_bad_non_null.csv")

total_matched_bad_null_value = total_matched_bad[value == "NULL"]
total_matched_bad_null_value %>%  
  fwrite(file = "./output/data/total_matched_bad_null_value.csv")

total_matched_bad_null_alnvalue = total_matched_bad[alnvalue == "NULL"] 
total_matched_bad_null_alnvalue %>%  
  fwrite(file = "./output/data/total_matched_bad_null_alnvalue.csv")
```

```{r results="asis"}
summary_diagnostic = total_matched_bad_non_null %>%  
  .[,.(fail = .N), by = .(src)] %>%  
  .[,`:=`(src = str_remove(src, "SED_"))]
  
```

```{r results='asis', fig.height=4, fig.width=8, fig.align='left'}
treemap::treemap(summary_diagnostic, 
                 index = "src", 
                 vSize = "fail", 
                 vColor = "fail",
                 type = "value", 
                 title = "Failed matches per originating source file, NULL reocrds removed")
```

```{r}
summary_diagnostic = total_matched_bad %>%  
  .[,.(fail = .N), by = .(assetattrid)] %>%  
  .[,`:=`(assetattrid = str_remove(assetattrid, "SED_"))] 
```

```{r results='asis', fig.height=4, fig.width=8, fig.align='left'}
treemap::treemap(summary_diagnostic, 
                 index = "assetattrid", 
                 vSize = "fail", 
                 vColor = "fail",
                 type = "value", 
                 title = "Failed matches per assetattributeid, NULL reocrds removed")
```
  
**`r nrow(total_matched_bad_non_null)`** mismatches occurred when neither alnvalue or value were NULL.   
These cases are of the most concern as they are legitimate mismatch errors. 
The records per source and assetattrid can be seen below:
```{r results="asis"}
total_matched_bad_non_null %>% 
  .[,.(.N), by = .(src, assetattrid)] %>%  
  .[order(-N)] %>% 
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "responsive"), full_width = T, font_size = 11) %>%
  scroll_box(height = "200px")  
```
**`r nrow(total_matched_bad_null_value)`** mismatches occurred when alnvalue was non-NULL and value was NULL.   
The records per source and assetattrid can be seen below:  
        
```{r results="asis"}
total_matched_bad_null_value %>% 
  .[,.(.N), by = .(src, assetattrid)] %>%  
  .[order(-N)] %>% 
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "responsive"), full_width = T, font_size = 11) %>%
  scroll_box(height = "200px") 
```

**`r nrow(total_matched_bad_null_alnvalue)`** mismatches occurred when alnvalue was NULL and value was non-NULL.   
The records per source and assetattrid can be seen below:    
   
```{r results="asis"}
total_matched_bad_null_alnvalue %>% 
  .[,.(.N), by = .(src, assetattrid)] %>%  
  .[order(-N)] %>% 
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "responsive"), full_width = T, font_size = 11) %>%
  scroll_box(height = "200px")  
```

## Match Error Investigation
***

### Missing attributes in ASSETSPEC
***
This is a big problem and needs to be fixed.
   
Fixes/comments:
   
* Consistent attribute naming in the source files
  - Remove duplicate column names in souce files
* Flagging source file attribute names when we know they are going to be changed in ASSETSPEC
* Some ability to make the mapping better between changed attributeids

### Date Errors
***
```{r results = "asis"}
index = grepl("DATE", total_matched_bad$assetattrid)

tmp_time_dt = total_matched_bad[str_detect(assetattrid, "DATE") ,] 
```

As seen in the above plot, a bulk of the valid record mismatches are from the *DATE* attributes.

There are **`r nrow(tmp_time_dt)`** records where a *DATE* related attribute caused a mismatched record. 
  
Fixes/comments:
  
* Mismatch error caused by the ASSETSPEC alnvalues being formatted as a #### numeric
* this is not UNIX or some common time format
* They need to be reformatted to %Y-%m-%d %H:%M:%S format
   
```{r results = "asis"}
tmp_time_dt[, c(1,5,7,8)] %>% 
  unique() %>% 
  sample_n(10) %>% 
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "responsive"), full_width = T, font_size = 11)
```


```{r results = "asis"}
# holla = tmp_time_dt %>%
#   .[,`:=`(alnvalue_nu = alnvalue %>%
#             as.numeric() %>%
#             round(0) %>%
#             as.Date(origin = "1900-01-01", format = "%Y-%m-%d"))] %>% 
#   .[,`:=`(value_nu = value %>%
#             ymd_hms() %>%
#             as_date())] %>% 
#    .[,`:=`(diff = alnvalue_nu - value_nu)] 
# 
# count = holla[,.(count = .N), by = diff] %>%  
#   .[order(-count)]
# 
# holla %>% 
#   .[is.na(diff)]
```


### Special character formatting
***
The SED_Dimensions assetattidid used unconventional formatting for dimensions. 
   
Fixes/comments:   
      
* Uses single and double quotes to indicate feet or inches presumably
* This is bad practice ideally be parsed into separate length and width components.
* Reported units are also inconsistent, and should be either all in feet or inches.
    
```{r results = "asis"}
attribute_value_notmatching[assetattrid == "SED_DIMENSIONS"] %>% 
  sample_n(5) %>% 
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "responsive"), full_width = T, font_size = 11) 

yolo1 = nrow(total_matched_bad[value == ""])
yolo2 = nrow(total_matched_bad[alnvalue == ""])
```

### Empty Values
***
Empty character values are being recorded only for the source file data values.  
After the source file and ASSETSPEC merge and removal of incomplete/NA records, there were:   
      
* **`r yolo1`** records where this occurs in the source file data
* **`r yolo2`** records where this occurs in the ASSETSPEC data

This match error is substantial as it accoutns for roughly **`r 100*round(yolo1/nrow(total_matched_bad),3)`** percent of the **`r nrow(total_matched_bad)`** total bad matches.
   
Fixes/comments:   
      
* Attributes properly map between data sets
* Spot checks reveal that attribute exists in source files but with an empty cell
* Empty cell in ASSETSPEC are reflected as NULL, in theory no-mismatch occuring
  + Can ignore these 
  + Or force empty cells to be NULL in source files

Table detailing orginating source files and correspoinging alnvalue:
```{r results = "asis"}
total_matched_bad[value == ""] %>% 
  .[,.(.N), by = .(src, alnvalue)] %>% 
  .[order(-N)] %>% 
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "responsive"), full_width = T, font_size = 11) %>%
  scroll_box(height = "200px")
```

Example of records:
```{r results = "asis"}
attribute_value_master[value == ""] %>%   
  sample_n(5) %>% 
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "responsive"), full_width = T, font_size = 11)  
```

# Richter Summary 
***
1) **From the total number of ASSETSPEC records, how many ASSETSPEC records are excluded and why?**        
The loaded ASSETSPEC was filtered to exclude the following items:    
*SEDTRACKSEGMENT%*, *SED_CULVERTSPAN_%*, *AMTMAX%*, and *%JCH%*.        
**`r nrow(asset)-nrow(asset_records_removed)`** OK, **`r nrow(asset_records_removed)`** NOT, (=Total **`r nrow(asset)`**)  

2) **Out of the total number of SED_ID values in ASSETSPEC, how many match the extract data?**    
Number of records where assetattrid == SED_ID was **`r first_num`**.   
The total number of these records which have NULL alnvalues was **`r bad_num`**.    
These were removed from the rest of the analysis.    
In total, there were **`r nrow(master_matched_ids)`** matches where assetattrid == SED_ID.   


3) **For every datapoint in the extract dataset that belongs to SED_IDs that are matched, how many of these have matching entries in the assetspec dataset (col name = assetattrid)?**   
Total Matches: **`r attribute_value_master_rows`**    
Complete Records: **`r attribute_value_master_good_row`**.     
Incomplete Records: **`r sum(ffmerge_summary_table$na_count)`**.  

* IR.1: **`r ffmerge_summary_table$na_count[1]`** -> no assetattrid value (ASSETSPEC side)     
* IR.2: **`r ffmerge_summary_table$na_count[2]`** -> no variable value (source file side)    
* IR.3: **`r ffmerge_summary_table$na_count[3]`** -> missing ASSETSPEC and sourve file data (attributes map)  
* IR.4: **`r ffmerge_summary_table$na_count[4]`** -> missing sourve file data (attributes map) 


4) **For every matched entry, does the alnvalue = the sed value? How many match and how many do not match?**    
Good Matches: **`r nrow(total_matched_good)`**    
Bad Matches: **`r nrow(total_matched_bad)`**    
Total Matches: **`r nrow(total_matched_bad) + nrow(total_matched_good)`**      
Percent Failure: **`r 100*nrow(total_matched_bad)/(nrow(total_matched_bad)+ nrow(total_matched_good))`** percent.     
See following files for more detail:    
total_matched_good -> all good matches  
total_matched_bad -> all bad matches  
total_matched_bad_non_null.csv -> slice of bad matches, where neither data set values are null  
total_matched_bad_null_value.csv -> slice of bad matches, where source file values are null  
total_matched_bad_null_alnvalue.csv -> slice of bad matches, where ASSETSPEC values are null  
total_matched_bad_null_only.csv - poor match instances where source could not be found, possibly due to multiple IDs 






